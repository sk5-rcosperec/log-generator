package main

import (
	"flag"
	"fmt"
	"time"

	"github.com/golang/glog"
	"k8s.io/apimachinery/pkg/util/rand"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"

	"github.com/pkg/errors"
)

var (
	httpMethods = []string{
		"POST",
		"GET",
		"CONNECT",
		"DELETE",
		"HEAD",
	}
	loglevel = []string{
		"info",
		"error",
		"warning",
		"WARNING",
		"ERROR",
		"INFO",
		"NOTICE",
		"err",
		"warn",
		"CRITICAL",
		"notice",
	}
	namespaces = []string{
		"kube-system",
		"default",
		"ns",
	}
)

var (
	linesTotal = flag.Int("log-lines-total", 0, "Total lines that should be generated by the end of the run")
	duration   = flag.Duration("run-duration", 0, "Total duration of the run")
	mode       = flag.String("mode", "json", "The mode in which the container is run, json or legacy")
)

func main() {

	flag.Parse()

	if *linesTotal <= 0 {
		glog.Fatalf("Invalid total number of lines: %d", *linesTotal)
	}

	if *duration <= 0 {
		glog.Fatalf("Invalid duration: %v", *duration)
	}
	fmt.Println(*mode)
	if *mode == "json" {
		generateJsons(*linesTotal, *duration)
	} else if *mode == "legacy" {
		generateLogs(*linesTotal, *duration)
	}
}

// Outputs linesTotal lines of logs to stdout uniformly for duration
func generateLogs(linesTotal int, duration time.Duration) {
	delay := duration / time.Duration(linesTotal)
	rand.Seed(time.Now().UnixNano())

	tick := time.Tick(delay)
	for id := 0; id < linesTotal; id++ {
		glog.Info(generateLogLine(id))
		<-tick
	}
}

// Generates apiserver-like line with average length of 100 symbols
func generateLogLine(id int) string {
	level := loglevel[rand.Intn(len(loglevel))]
	method := httpMethods[rand.Intn(len(httpMethods))]
	namespace := namespaces[rand.Intn(len(namespaces))]

	podName := rand.String(rand.IntnRange(3, 5))
	url := fmt.Sprintf("A message log that is quite long and happens in the fake namespace %s and fake pod %s. I'm going to keep going and add some special char {[ ]} $! ** ,; to the mix for more funnÃ¨ results", namespace, podName)
	status := rand.IntnRange(200, 600)

	return fmt.Sprintf("%d %s %s %s %d", id, level, method, url, status)
}

func generateJsons(linesTotal int, duration time.Duration) {
	delay := duration / time.Duration(linesTotal)
	rand.Seed(time.Now().UnixNano())

	tick := time.Tick(delay)
	for id := 0; id < linesTotal; id++ {
		generateJsonLine(id)
		<-tick
	}
}

func generateJsonLine(id int) {

	method := httpMethods[rand.Intn(len(httpMethods))]
	status := rand.IntnRange(200, 600)

	level := rand.Intn(4)

	switch level {
	case 0:
		log.Info().Msgf("%s status %d and this is and Info message so should be probably discarded and not logged in the first place but hey", method, status)
	case 1:
		log.Warn().Int("status", status).Str("httpmethod", method).Msgf("%s status %d and this is a Warning message that could be critical or totally anodectical depending on the dev", method, status)
	case 2:
		err := errors.New("That's an error")
		log.Error().Stack().Err(err).Msg("generated by error case")
	case 3:
		err := errors.New("That's a terrible error with dire consequences")
		service := "criticalserviced"
		log.WithLevel(zerolog.FatalLevel).Err(err).Str("service", service).Msg("The criticalserviced has a big problem")
	case 4:
		err := errors.New("That's a panic error, i'm panicking, really")
		service := "anotverycalmservice"
		log.WithLevel(zerolog.PanicLevel).Err(err).Int("status", status).Str("httpmethod", method).Str("service", service).Msg("Karma is a bitch, or so it seems.")
	}

}
