package main

import (
	"flag"
	"fmt"
	"time"

	"github.com/golang/glog"
	"k8s.io/apimachinery/pkg/util/rand"
)

var (
	httpMethods = []string{
		"info",
		"error",
		"warning",
		"WARNING",
		"ERROR",
		"INFO",
		"NOTICE",
		"err",
		"warn",
		"CRITICAL",
		"notice",
	}
	namespaces = []string{
		"kube-system",
		"default",
		"ns",
	}
)

var (
	linesTotal = flag.Int("log-lines-total", 0, "Total lines that should be generated by the end of the run")
	duration   = flag.Duration("run-duration", 0, "Total duration of the run")
)

func main() {
	flag.Parse()

	if *linesTotal <= 0 {
		glog.Fatalf("Invalid total number of lines: %d", *linesTotal)
	}

	if *duration <= 0 {
		glog.Fatalf("Invalid duration: %v", *duration)
	}

	generateLogs(*linesTotal, *duration)
}

// Outputs linesTotal lines of logs to stdout uniformly for duration
func generateLogs(linesTotal int, duration time.Duration) {
	delay := duration / time.Duration(linesTotal)
	rand.Seed(time.Now().UnixNano())

	tick := time.Tick(delay)
	for id := 0; id < linesTotal; id++ {
		glog.Info(generateLogLine(id))
		<-tick
	}
}

// Generates apiserver-like line with average length of 100 symbols
func generateLogLine(id int) string {
	method := httpMethods[rand.Intn(len(httpMethods))]
	namespace := namespaces[rand.Intn(len(namespaces))]

	podName := rand.String(rand.IntnRange(3, 5))
	url := fmt.Sprintf("/api/v1/namespaces/%s/pods/%s", namespace, podName)
	status := rand.IntnRange(200, 600)

	return fmt.Sprintf("%d %s %s %d", id, method, url, status)
}
